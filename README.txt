Ιωάννης Δαλιάνης


Τα δεδομένα για τα diseaseRecords των ασθενών αποθηκεύονται μία μόνο φορά στη μνήμη.
Χρησιμοποιείται μια Απλά Συνδεδεμένη Λίστα για να κρατάει τους αρχικούς δείκτες προς
τα diseaseRecords η οποία δε μεταβάλλεται καθόλου μέχρι το τέλος της εκτέλεσης του προγράμματος,
με εξαίρεση την περίπτωση της querry insertPatientRecord. Οι άλλες δομές αποθηκεύουν πάλι 
μόνο δείκτες στα diseaseRecords και όταν αυτές σβήνονται, δε πειράζουν καθόλου 
τα diseaseRecords. Τα diseaseRecords σβήνονται μόνο στο τέλος που αδειάζει η Απλά 
Συνδεδεμένη Λίστα.




AVL
Έστω ότι οι τιμές βάσει των οποίων εισάγονται και κατανέμονται νέοι κόμβοι στο AVL Δέντρο
ονομάζονται AVL κλειδιά.
Τα AVL κλειδιά που έχουν τιμή ίση με αυτή του τρέχοντος AVL κόμβου κατανέμονται προς τα
δεξιά παιδιά του, μαζί δηλαδή με τους AVL κόμβους που έχουν μεγαλύτερες τιμές AVL
κλειδιών από αυτόν.



Η συνάρτηση για τα AVL performRotations ελέγχει αν μετά από μία εισαγωγή στο δέντρο απαιτείται
κάποιο rotation. Για ένα κόμβο existent ελέγχεται πρώτα για rotation το δεξί του υπόδεντρο και
έπειτα το αριστερό. Οι έλεγχοι που γίνονται με τις μεταβλητές balance, newcompare,
does_it_have_at_least_one_not_NULL_child εξασφαλίζουν ότι για να γίνει rotation στο
subtree ενός κόμβου πρέπει και το balance factor να έχει τιμή μικρότερη του -1 ή μεγαλύτερη του 1
και ο καινούριος κόμβος added να έχει εισαχθεί στο υπόδεντρο που ελέγχουμε αλλά και το child node του
κόμβου existent να έχει τουλάχιστον ένα παιδί. Αν δεν έχει σημαίνει ότι το child node του existent
είναι αυτό που μόλις εισήχθη, οπότε δεν γίνεται κάποιο rotation στο συγκεκριμένο υπόδεντρο.

Είναι πιθανό τα rotations στην υλοποίησή μου να τα έχω ονομάσει αντίθετα σε σχέση με την πλειονότητα
των παραδειγμάτων που υπάρχουν στο ίντερνετ, π.χ. LL αντί για RR κ.λ.π.

Η συνάρτηση recPrintAVLNode φτιάχτηκε μετά από μελέτη παρόμοιων συναρτήσεων εκτύπωσης
σε δενδρική μορφή.

Η ρίζα έχει nodeHeight το πλήθος των επιπέδων. Άρα το τελευταίο παιδί κάθε υποδέντρου έχει
nodeHeight 1. To nodeHeight κάθε κόμβου του AVL χρησιμεύει μόνο για τα rotations. Δεν
είναι πάντα το σωστό γιατί μπορεί πχ το δέντρο κάποια στιγμή να είναι πλήρως ισορροπημένο και
μετά να εισαχθεί ένας κόμβος. Το nodeHeight του κόμβου και όλων των προκατόχων του θα αλλάξει
αλλά όχι και των γειτονικών υποδέντρων.

Για όλες τις δομές έχουν υλοποιηθεί συναρτήσεις εκτύπωσης.

Οι ημερομηνίες αποθηκεύονται και επεξεργάζονται σα string της μορφής DD-MM-YYYY. Έχει
υλοποιηθεί συνάρτηση που συγκρίνει δύο ημερομηνίες επιστρέφοντας int τιμές ανάλογα με το
ποια ημερομηνία είναι μεταγενέστερη, αν κάποια είναι "-" κλπ.

Σε όλη την άσκηση στα σημεία που σαν όρισμα λαμβάνεται ημερομηνία, δε γίνεται έλεγχος αν το
string που δίνεται είναι της μορφής DD-MM-YYYY. Υποθέτουμε ότι όπου χρειάζεται δίνεται σωστή ημερομηνία
σαν input.

Η συνάρτση get_child_nodes επιστρέφει τον αριθμό των παιδιών ενός κόμβου συν τον ίδιο τον κόμβο
και χρησιμοποιείται για το Querry globalDiseaseStats.

Hash Table:
Από Piazza: Το bucketSize χρειάζεται για να ορίσει το ποσα entries χωράει το Bucket. Αν έχω
bucketSize = 128 bytes και καθε entry ειναι 16 bytes τοτε το bucket χωραει 128 / 16 =  8 εγγραφές.

Η hashFunction δέχεται ένα string και έναν ακέραιο διαιρέτη. Αθροίζει τις int τιμές κάθε χαρακτήρα
του int και επιστρέφει το υπόλοιπο της διαίρεσης του αθροίσματος με το διαιρέτη.


Στη συνάρτηση που δημιουργεί ένα Hash Table γίνεται έλεγχος για την παράμετρο bucketSize που
έχει δοθεί. Κάθε δομή Bucket περιέχει έναν πίνακα void pointer. Αυτοί οι pointers δουλεύουν κατά
ζεύγη. Ο ένας δείχνει στο όνομα του ιού/χώρας και ο επόμενος δείχνει στο AVL δέντρο που αποθηκεύει
τα αντίστοιχα records ασθενών. Το μέγεθος ενός void pointer είναι 8 bytes. Για να λειτουργήσει το
πρόγραμμα πρέπει να μπορεί το κάθε bucket να αποθηκεύσει τουλάχιστον 2 void pointers, δηλαδή πρέπει
το bucketSize να είναι τουλάχιστον 16. Αν είναι λιγότερο το πρόγραμμα τερματίζεται. Επίσης οι pointers
πάνε αναγκαστικά κατά ζευγάρια, οπότε αν με δεδομένο ένα bucketSize υπάρχει υπόλοιπο στη διαίρεση
bucketSize/16 bytes τότε αυτό ουσιαστικά δε χρησιμοποιείται.

Για την υλοποίηση του Max Heap το id χρησιμοποιείται για να τοποθετηθούν οι κόμβοι στο δέντρο
διατηρώντας το χαρακτηριστικό του complete binary tree όπου οι κόμβοι μπαίνουν όσο πιο αριστερά
γίνεται σε κάθε επίπεδο. Το δέντρο κατανέμεται με βάση το πεδίο total κάθε κόμβου, που κρατάει
τον αριθμό φορών που βρέθηκε ένα country ή ένα disease. Όταν υπάρχει ανάγκη για reheapification,
οι δύο κάθε φορά εμπλεκόμενοι κόμβοι απλά ανταλλάσουν μεταξύ τους τα περιεχόμενα occurence και total.
Συνεπώς τα id μένουν πάντα στη θέση που πρωτοεισήχθησαν και έτσι είναι και στη συνέχεια η εισαγωγή
νέων κόμβων. Για τις εντολές topk, κάθε κόμβος, αφότου εκτυπωθεί το περιεχόμενό του, το total του
γίνεται 0 και το occurence του "$$$$$$$$$$$" για να μη ξανασχοληθούμε μαζί του στις υπόλοιπες
εκτυπώσεις. Μετά από αυτό γίνεται reheapification του δέντρου για να ανέβει πάνω το αμέσως μεγαλύτερο
σε εμφανίσεις στοιχείο. Δεν έχει υλοποιηθεί κανονική διαγραφή από Heap καθώς μετά την εκτύπωση των
k κόμβων το δέντρο έτσι κι αλλιώς διαγράφεται.

Αν στα Querries, για το insertPatientRecord δοθεί record με Id που υπάρχει ήδη, εμφανίζεται αντίστοιχο
μήνυμα, χωρίς όμως να τερματίζεται το πρόγραμμα όπως στην περίπτωση της αρχικής εισαγωγής records.

Η συνάρτση takeString έχει παρθεί από το stackOverflow.



globalDiseaseStats 20-01-2005 20-04-2019
topk-Diseases 15 Australia 03-07-2001 28-05-2008
topk-Countries 15 EVD 03-07-2001 28-05-2008
diseaseFrequency EVD 03-07-2001 28-05-2008
diseaseFrequency COVID-2019 03-07-2000 28-05-2010 Turkey
insertPatientRecord 700000 Johny Patatas EVD Japan 10-09-2003 10-09-2017
recordPatientExit 855 16-02-2006
numCurrentPatients FLU-2018



README tha steilo kai pdf kai txt

ίσως τα Ids να ελέγχονται και σα strings απλά πχ ένα να είναι 1i3gy13u
μέχρι τώρα λογικά όλα είναι με strcmp
τα ids μπορώ να τα συγκρίνω με strcmp και αυτή να είναι η αξία σύγκρισής μου
να δίνεται κενό το τελευταίο στο insertnewpatient


int strcmp(const char *str1, const char *str2)
This function return values that are as follows −

    if Return value < 0 then it indicates str1 is less than str2.

    if Return value > 0 then it indicates str2 is less than str1.

    if Return value = 0 then it indicates str1 is equal to str2.
